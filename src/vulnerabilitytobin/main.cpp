#include <cstdio>
#include <cstdlib>
#include <cstring>

#include "../include/oasis.h"
#include "vulnerabilitytobin.h"

#if defined(_MSC_VER)
#include "../wingetopt/wingetopt.h"
#else
#include <unistd.h>
#endif

#if !defined(_MSC_VER) && !defined(__MINGW32__)
#include <csignal>
#endif

char *progname;

#if !defined(_MSC_VER) && !defined(__MINGW32__)
void SegFaultSigAction(int, siginfo_t *si, void *) {
  fprintf(stderr, "ERROR: %s: Segment fault at address: %p\n",
          progname, si->si_addr);
  exit(EXIT_FAILURE);
}
#endif


void Help() {

  fprintf(stderr, "-d [value] maximum damage bin index\n"
		  "-i use index file\n"
		  "-z zip footprint data\n"
		  "-N no validation checks\n"
		  "-S suppress all intensity bins present for each vulnerability ID validation checks (recommended for multiple peril models)\n"
		  "-h help\n"
		  "-v version\n");

}


void DoIt(const int maxDamageBinIdx, const char* binFileName,
	  const char* idxFileName, const bool useIndexFile, const bool zip,
	  const bool validationCheck, const bool allIntensityBinsCheck) {

  VulnerabilityToBin vTB(maxDamageBinIdx, binFileName, idxFileName,
			 useIndexFile, zip, allIntensityBinsCheck);
  vTB.SkipHeaderRow();
  vTB.WriteHeader();

  if (validationCheck) {

    vTB.ReadVulnerabilityFile();
    vTB.PrintSuccessMessage();

    return;

  }

  vTB.ReadVulnerabilityFileNoChecks();

}


int main(int argc, char *argv[]) {

  progname = argv[0];
  int maxDamageBinIdx = -1;
  char binFileName[4096] = "vulnerability.bin";
  char idxFileName[4096] = "vulnerability.idx";
  bool useIndexFile = false;
  bool zip = false;
  bool validationCheck = true;
  bool allIntensityBinsCheck = true;
  int opt;
  while ((opt = getopt(argc, argv, "d:izNShv")) != -1) {
    switch (opt) {
      case 'd':
        maxDamageBinIdx = atoi(optarg);
	break;
      case 'i':
	useIndexFile = true;
	break;
      case 'z':
	zip = true;
        strcat(binFileName, ".z");
	strcat(idxFileName, ".z");
	break;
      case 'N':
	validationCheck = false;
	break;
      case 'S':
	allIntensityBinsCheck = false;
	break;
      case 'v':
	fprintf(stderr, "%s : version : %s\n", argv[0], VERSION);
        exit(EXIT_FAILURE);
      case 'h':
      default:
	Help();
	exit(EXIT_FAILURE);
    }
  }

  if (maxDamageBinIdx == -1) {
    fprintf(stderr, "ERROR: Damage bin parameter not supplied.\n");
    exit(EXIT_FAILURE);
  }

  // There is no need for user to give command line argument for index file
  // creation when zip output is requested.
  if (zip) {
    if (useIndexFile) {
      fprintf(stderr, "INFO: Index files are always created when zip output is"
		      " requested.\n");
    }
    useIndexFile = zip;   // Ensure downstream conditionals work
  }

#if !defined(_MSC_VER) && !defined(__MINGW32__)
  struct sigaction sa;

  memset(&sa, 0, sizeof(struct sigaction));
  sigemptyset(&sa.sa_mask);
  sa.sa_sigaction = SegFaultSigAction;
  sa.sa_flags = SA_SIGINFO;

  sigaction(SIGSEGV, &sa, NULL);
#endif

  try {

    initstreams();
    DoIt(maxDamageBinIdx, binFileName, idxFileName, useIndexFile, zip,
	 validationCheck, allIntensityBinsCheck);
    return 0;

  } catch (std::bad_alloc&) {

    fprintf(stderr, "ERROR: %s: Memory allocation failed.\n", progname);
    exit(EXIT_FAILURE);

  }

}
