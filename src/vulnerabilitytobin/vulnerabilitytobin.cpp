#include <cstdio>
#include <cstdlib>
#include <cstring>

#include <zlib.h>

#include "../include/oasis.h"
#include "vulnerabilitytobin.h"


VulnerabilityToBin::VulnerabilityToBin(const int maxDamageBinIdx,
				       const char* binFileName,
				       const char* idxFileName,
				       const bool useIndexFile, const bool zip,
				       const bool allIntensityBinsCheck) :
  ValidateVulnerability(allIntensityBinsCheck),
  maxDamageBinIdx_(maxDamageBinIdx), zip_(zip) {

  strcpy(fileDescription_, "Vulnerability");
  convertToBin_ = true;
  useIndexFile_ = useIndexFile;
  if (useIndexFile_) {
    fileOutBin_ = fopen(binFileName, "wb");
    fileOutIdx_ = fopen(idxFileName, "wb");
  } else {
    fileOutBin_ = stdout;
  }

}


VulnerabilityToBin::~VulnerabilityToBin() {

  fclose(fileOutBin_);
  if (useIndexFile_) fclose(fileOutIdx_);

}


void VulnerabilityToBin::ReadVulnerabilityFileNoChecks() {

  ReadFirstVulnerabilityLine();
  WriteBinVulnerabilityFile();

  while (fgets(line_, sizeof(line_), stdin) != 0) {

    if (ScanLine() == 4) {

      v_.vulnerability_id = int(initialVulID_);

      if (useIndexFile_) {

        if (v_.vulnerability_id != prevVulID_) {

          WriteIdxVulnerabilityFile();
	  prevVulID_ = v_.vulnerability_id;

        }

      }

      WriteBinVulnerabilityFile();
      continue;

    }

    fprintf(stderr, "ERROR: Invalid data in line %d:\n%s\n", lineno_, line_);
    PrintErrorMessage();

  }

  if (useIndexFile_) WriteIdxVulnerabilityFile();

}


void VulnerabilityToBin::WriteHeader() {

  fwrite(&maxDamageBinIdx_, sizeof(maxDamageBinIdx_), 1, fileOutBin_);

  if (useIndexFile_) vIdx_.offset = sizeof(maxDamageBinIdx_);

}


void VulnerabilityToBin::WriteBinVulnerabilityFile() {

  // Check that damage bin ID from file does not exceed maximum in header
  if (v_.damage_bin_id > maxDamageBinIdx_) {
    fprintf(stderr, "ERROR: Maximum damage bin index of %d in header is less"
		    " than that of %d in line %d:\n%s\n",
	    maxDamageBinIdx_, v_.damage_bin_id, lineno_, line_);
    exit(EXIT_FAILURE);
  }

  // If there is no index file, write vulnerability data as it comes in
  if (!useIndexFile_) {
    fwrite(&v_, sizeof(v_), 1, fileOutBin_);
    return;
  }

  // Otherwise write intensity bin ID, damage bin ID and probability to binary
  // vulnerability file
  VulnerabilityRow vr = { v_.intensity_bin_id,
			  v_.damage_bin_id,
			  v_.probability };
  ++rowCount_;   // Increment row counter

  // Write binary vulnerability file if no zip output requested
  if (!zip_) {

    fwrite(&vr, sizeof(vr), 1, fileOutBin_);
    return;

  }

  // Otherwise, store in vector
  vulnerabilityRows_.push_back(vr);

}


void VulnerabilityToBin::WriteIdxVulnerabilityFile() {

  vIdx_.vulnerability_id = prevVulID_;
  vIdx_.size = rowCount_ * sizeof(VulnerabilityRow);

  if (zip_) {

    std::vector<unsigned char> zvr;
    zvr.resize(vulnerabilityRows_.size() * sizeof(VulnerabilityRow) + 1024);
    unsigned long zippedVulnerabilityRowsLength = zvr.size();
    compress(&zvr[0], &zippedVulnerabilityRowsLength,
	     (unsigned char*)&vulnerabilityRows_[0],
	     vulnerabilityRows_.size() * sizeof(VulnerabilityRow));
    fwrite((unsigned char*)&zvr[0], zippedVulnerabilityRowsLength, 1,
	   fileOutBin_);

    // Overwrite with actual size of compressed buffer
    vIdx_.size = zippedVulnerabilityRowsLength;

    vIdx_.original_size = rowCount_ * sizeof(VulnerabilityRow);

    vulnerabilityRows_.clear();   // Reset

  }

  fwrite(&vIdx_, sizeof(vIdx_), 1, fileOutIdx_);

  // Set new offset and reset row counter
  vIdx_.offset += vIdx_.size;
  rowCount_ = 0;

}
