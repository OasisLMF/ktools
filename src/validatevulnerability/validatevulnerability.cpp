#include <cmath>
#include <cstring>
#include <iostream>
#include <map>
#include <set>
#include <stdio.h>
#include <stdlib.h>

#include "../include/oasis.h"

#if defined(_MSC_VER)
#include "../wingetopt/wingetopt.h"
#else
#include <unistd.h>
#endif

namespace validatevulnerability {

  inline bool ProbabilityCheck(float prob) {

    return roundf(prob * 10000) / 10000 != 1.0;

  }

  inline bool ProbabilityError(Vulnerability v, float prob) {

    fprintf(stderr, "Probabilities for vulnerability ID %d", v.vulnerability_id);
    fprintf(stderr, " and intensity bin ID %d", v.intensity_bin_id);
    fprintf(stderr, " do not sum to 1.\n");
    fprintf(stderr, "Probability = %f\n", prob);

    return false;

  }

  inline void SetMaximumIntensityBinForVulnerabilityID(
    std::map<int, int>& vulID_to_maxIntensityBin, const Vulnerability& p) {

    // In case of repeated rows or for vulnerability IDs not in ascending order,
    // check that the intensity bin ID is actually the maximum for that
    // vulnerability ID
    if (vulID_to_maxIntensityBin.find(p.vulnerability_id) ==
	vulID_to_maxIntensityBin.end()) {

      vulID_to_maxIntensityBin[p.vulnerability_id] = p.intensity_bin_id;

    } else if (vulID_to_maxIntensityBin[p.vulnerability_id] <
	       p.intensity_bin_id) {

      vulID_to_maxIntensityBin[p.vulnerability_id] = p.intensity_bin_id;

    }

  }

  inline void SetMaximumIntensityBin(const int _maxIntensityBin,
		  		     int& maxIntensityBin) {

    if (maxIntensityBin < _maxIntensityBin) maxIntensityBin = _maxIntensityBin;

  }

  void doit() {

    Vulnerability p = {}, q;
    bool dataValid = true;
    std::set<int> damageBins;
    int maxDamageBin = 0;
    int maxIntensityBin = 0;
    std::map<int, int> vulID_to_maxIntensityBin;
    float prob = 0.0;
    char prevLine[4096], line[4096];
    sprintf(prevLine, "%d, %d, %d, %f", p.vulnerability_id, p.intensity_bin_id,
	    p.damage_bin_id, p.probability);
    int lineno = 0;
    fgets(line, sizeof(line), stdin);   // Skip header line
    lineno++;

    while(fgets(line, sizeof(line), stdin) != 0) {

      // Check for invalid data
      if(sscanf(line, "%d,%d,%d,%f", &q.vulnerability_id, &q.intensity_bin_id,
		&q.damage_bin_id, &q.probability) != 4) {

	fprintf(stderr, "Invalid data in line %d:\n%s\n", lineno, line);
	dataValid = false;

      }

      // New vulnerability ID
      if(q.vulnerability_id != p.vulnerability_id) {

	// Check total probability for vulnerability-intensity bin combination
	// is 1.0
	if(ProbabilityCheck(prob) && p.vulnerability_id != 0) {

	  dataValid = ProbabilityError(p, prob);

	}

	damageBins.clear();
	prob = 0.0;

	// Check vulnerability IDs listed in ascending order
	if(q.vulnerability_id < p.vulnerability_id) {

	  fprintf(stderr, "Vulnerability ID in lines %d and %d", lineno-1, lineno);
	  fprintf(stderr, " not in ascending order:\n");
	  fprintf(stderr, "%s\n%s\n", prevLine, line);

	  dataValid = false;

	}

	// Skip first vulnerability ID for now
	// If it is the only vulnerability ID it will be taken care of later
	if (p.vulnerability_id != 0) {

	  // Determine maximum intensity bin ID for each vulnerability ID
	  SetMaximumIntensityBinForVulnerabilityID(vulID_to_maxIntensityBin, p);

	  // Get new maximum intensity bin ID if applicable
	  SetMaximumIntensityBin(vulID_to_maxIntensityBin[p.vulnerability_id],
				 maxIntensityBin);

	}

      } else if(q.intensity_bin_id != p.intensity_bin_id) {

	// Check total probability for vulnerability-intensity bin combination
	// is 1.0
	if(ProbabilityCheck(prob)) {

	  dataValid = ProbabilityError(p, prob);

	}

	damageBins.clear();
	prob = 0.0;

	// Check intensity bin IDs are contiguous
	if(p.intensity_bin_id != q.intensity_bin_id-1) {

	  fprintf(stderr, "Non-contiguous intensity bin IDs");
	  fprintf(stderr, " in lines %d and %d\n", lineno-1, lineno);
	  fprintf(stderr, "%s\n%s\n", prevLine, line);

	  dataValid = false;

	}

      }

      // Check no duplicate damage bins for each vulnerability-intensity bin
      // combination
      if(damageBins.find(q.damage_bin_id) == damageBins.end()) {

	damageBins.insert(q.damage_bin_id);
	prob += q.probability;

	// Get maximum value of damage_bin_index
	if(q.damage_bin_id > maxDamageBin) {

	  maxDamageBin = q.damage_bin_id;

	}

      } else {

	fprintf(stderr, "Duplicate damage bin for");
	fprintf(stderr, " vulnerability-intensity bin combination\n");
	fprintf(stderr, "%s\n", line);
	dataValid = false;

      }

      lineno++;
      p = q;
      memcpy(prevLine, line, strlen(line)+1);
      prevLine[strlen(line)-1] = '\0';

    }

    // Check total probability for last vulnerability-intensity bin combination
    // is 1.0
    if(ProbabilityCheck(prob)) {

      dataValid = ProbabilityError(q, prob);

    }

    // Determine maximum intensity bin ID for last vulnerability ID
    SetMaximumIntensityBinForVulnerabilityID(vulID_to_maxIntensityBin, q);

    // Get new maximum intensity bin ID if applicable
    SetMaximumIntensityBin(vulID_to_maxIntensityBin[q.vulnerability_id],
		    	   maxIntensityBin);

    // Loop through vulnerability_id-maximum_intensity_bin_id map to ensure all
    // intensity bins are present
    for (std::map<int, int>::iterator it=vulID_to_maxIntensityBin.begin();
	 it!=vulID_to_maxIntensityBin.end(); ++it) {

      if (maxIntensityBin > it->second) {

	fprintf(stderr, "Vulnerability ID %d: ", it->first);
	fprintf(stderr, "%d out of %d intensity bins present\n", it->second,
		maxIntensityBin);

	dataValid = false;

      }

    }

    if(dataValid == true) {

      fprintf(stderr, "All checks pass.\n");
      fprintf(stderr, "Maximum value of damage_bin_index = %d\n", maxDamageBin);

    } else {

      fprintf(stderr, "Some checks have failed. Please edit input file.\n");

    }

  }

}
