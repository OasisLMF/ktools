#include <algorithm>
#include <climits>
#include <cstdio>
#include <cstring>
#include <iterator>
#include <set>

#include "validatevulnerability.h"


int ValidateVulnerability::ScanLine() {
/* The probability field is defined according to the data type assigned to
 * OASIS_FLOAT in include/oasis.h */

#ifdef OASIS_FLOAT_TYPE_DOUBLE
  return sscanf(line_, "%lld,%d,%d,%lf", &initialVulID_, &v_.intensity_bin_id,
					 &v_.damage_bin_id, &v_.probability);
#else
  return sscanf(line_, "%lld,%d,%d,%f", &initialVulID_, &v_.intensity_bin_id,
					&v_.damage_bin_id, &v_.probability);
#endif

}


inline void ValidateVulnerability::CheckVulnerabilityID() {
/* Check vulnerability ID does not exceed maximum integer value and
 * vulnerability IDs are in ascending order. */

  if (initialVulID_ > INT_MAX) {

    fprintf(stderr, "ERROR: Vulnerability ID %lld on line %d exceeds maximum"
		    " permissible value %d. Please reassign vulnerability IDs"
		    " to lie under this maximum.\n",
	    initialVulID_, lineno_, INT_MAX);
    PrintErrorMessage();

  }

  v_.vulnerability_id = int(initialVulID_);

  if (prevVulID_ <= v_.vulnerability_id) return;

  fprintf(stderr, "ERROR: Vulnerability IDs %d and %d in lines %d and %d"
		  " respectively are not in ascending order:\n%s\n%s\n",
	  prevVulID_, v_.vulnerability_id, lineno_ - 1, lineno_, line_,
	  prevLine_);
  PrintErrorMessage();

}


inline void ValidateVulnerability::CheckProbability(const OASIS_FLOAT totalProbability) {

  int probCheck = (int)(totalProbability * 10000 + 0.5);
  if (probCheck != 10000) {

    fprintf(stderr, "ERROR: Probabilities for vulnerability ID %d and"
		    " intensity bin ID %d do not sum to 1.0"
		    " (total probability = %f).\n",
	    prevVulID_, prevIntBinID_, totalProbability);
    PrintErrorMessage();

  }

}


inline void ValidateVulnerability::SetIntensityBinIDs() {
/* Fill sets with intensity bin IDs used in check at end to establish that
 * each vulnerability ID has entries for all intensity bin IDs. This check is
 * only relevant in single peril models, and can be supressed by the user
 * through a command line argument. */

  std::set<int>::iterator itVulHint = vulIDToIntBinIDs_[v_.vulnerability_id].end();
  vulIDToIntBinIDs_[v_.vulnerability_id].insert(itVulHint, v_.intensity_bin_id);

  std::set<int>::iterator itIntHint = intensityBinIDs_.begin();
  if (v_.intensity_bin_id > (int)intensityBinIDs_.size()) {
    itIntHint = intensityBinIDs_.end();
  } else {
    itIntHint = intensityBinIDs_.begin();
    std::advance(itIntHint, v_.intensity_bin_id);
  }
  intensityBinIDs_.insert(itIntHint, v_.intensity_bin_id);

}


inline void ValidateVulnerability::CheckIntensityBinID() {

  if ((v_.intensity_bin_id - 1) != prevIntBinID_) {

    fprintf(stderr, "ERROR: Non-contiguous intensity bin IDs %d on line %d"
                    " and %d on line %d:\n%s\n%s\n",
            prevIntBinID_, lineno_ - 1, v_.intensity_bin_id, lineno_,
            prevLine_, line_);
    PrintErrorMessage();

  }

  if (allIntensityBinsCheck_) SetIntensityBinIDs();

}


inline void ValidateVulnerability::StoreLine() {
/* Store current line before going to the next one. Used in some error message
 * output. */

    ++lineno_;
    prevVulID_ = v_.vulnerability_id;
    prevIntBinID_ = v_.intensity_bin_id;
    if (v_.damage_bin_id > maxDamageBin_) {
      // Maximum damage bin index is a required argument to convert
      // vulnerability csv files to binary format with vulnerabilitytobin
      maxDamageBin_ = v_.damage_bin_id;
    }
    memcpy(prevLine_, line_, strlen(line_) + 1);
    prevLine_[strlen(line_) - 1] = '\0';

}


void ValidateVulnerability::ReadFirstVulnerabilityLine(OASIS_FLOAT &totalProbability) {

  if (fgets(line_, sizeof(line_), stdin) != 0) {

    if (ScanLine() == 4) {

      CheckVulnerabilityID();
      StoreLine();
      damageBinIDs_.push_back(v_.damage_bin_id);
      maxDamageBin_ = v_.damage_bin_id;   // Set initial value
      totalProbability = v_.probability;

      return;

    }

    fprintf(stderr, "ERROR: Invalid data in line %d:\n%s\n", lineno_, line_);
    PrintErrorMessage();

  }

  fprintf(stderr, "ERROR: Empty file\n");
  PrintErrorMessage();

}


inline void ValidateVulnerability::CheckDamageBins() {

  if (find(damageBinIDs_.begin(), damageBinIDs_.end(),
	   v_.damage_bin_id) == damageBinIDs_.end()) {

    damageBinIDs_.push_back(v_.damage_bin_id);

    return;

  }

  fprintf(stderr, "ERROR: Duplicate damage bin %d on line %d for"
		  " vulnerability ID %d and intensity bin ID %d:\n%s\n",
	  v_.damage_bin_id, lineno_, v_.vulnerability_id, v_.intensity_bin_id,
	  line_);
  PrintErrorMessage();

}


void ValidateVulnerability::CheckAllIntensityBinsPresent() {
/* Each vulnerability ID should have entries for all intensity bins in single
 * peril models. As it is not possible to establish from the vulnerability file
 * alone whether it belongs to a single peril model, this is issued as a
 * warning. This check can be supressed with a command line argument. */

  for (auto iter = vulIDToIntBinIDs_.begin(); iter != vulIDToIntBinIDs_.end();
       ++iter) {

    if (iter->second.size() != intensityBinIDs_.size()) {

      warnings_ = true;

      std::set<int> missingIntensityBins;
      std::set_difference(intensityBinIDs_.begin(), intensityBinIDs_.end(),
			  iter->second.begin(), iter->second.end(),
			  std::inserter(missingIntensityBins,
					missingIntensityBins.end()));

      char bins[5] = "bin";
      if (missingIntensityBins.size() > 1) strcat(bins, "s");
      fprintf(stderr, "WARNING: Vulnerability ID %d: Intensity %s ",
	      iter->first, bins);
      int numberOfMissingBinsLeft = missingIntensityBins.size();

      for (auto missBinsIter = missingIntensityBins.begin();
	   missBinsIter != missingIntensityBins.end(); ++missBinsIter) {
        fprintf(stderr, "%d", *missBinsIter);
	if (numberOfMissingBinsLeft > 2) {
          fprintf(stderr, ", ");
	} else if (numberOfMissingBinsLeft == 2) {
          fprintf(stderr, " and ");
	}
	--numberOfMissingBinsLeft;
      }
      fprintf(stderr, " missing. All intensity bins must be present for each"
		      " vulnerability ID in single peril models.\n");

    }

  }

}


void ValidateVulnerability::ReadVulnerabilityFile() {

  OASIS_FLOAT totalProbability = 0.0;
  ReadFirstVulnerabilityLine(totalProbability);
  // Write first vulnerability line
  if (convertToBin_) WriteBinVulnerabilityFile();

  while (fgets(line_, sizeof(line_), stdin) != 0) {

    if (ScanLine() == 4) {

      CheckVulnerabilityID();

      // New vulnerability and/or intensity bin IDs.
      // Check probabilities sum to 1.0  for each vulnerability ID-intensity
      // bin ID combination and intensity bin IDs are contiguous.
      if ((v_.vulnerability_id != prevVulID_) ||
	  (v_.intensity_bin_id != prevIntBinID_)) {

        CheckProbability(totalProbability);
	if (v_.vulnerability_id == prevVulID_) {

	  CheckIntensityBinID();

	} else if (useIndexFile_) {

	// if new vulnerability ID then write to index file if requested on
	// command line
	  WriteIdxVulnerabilityFile();

	}

	// Reset for next event
	damageBinIDs_.clear();
	damageBinIDs_.push_back(v_.damage_bin_id);
	totalProbability = v_.probability;

      } else {   // Only damage bin ID changes

        CheckDamageBins();
	totalProbability += v_.probability;

      }

      if (convertToBin_) {

        WriteBinVulnerabilityFile();

      }

      StoreLine();
      continue;

    }

    fprintf(stderr, "ERROR: Invalid data in line %d:\n%s\n", lineno_, line_);
    PrintErrorMessage();

  }

  // Check probabilities sum to 1.0 for last vulnerability ID-intensity bin ID
  // combination and intensity bin IDs are contguous.
  CheckProbability(totalProbability);
  if ((v_.vulnerability_id == prevVulID_) &&
      (v_.intensity_bin_id != prevIntBinID_)) CheckIntensityBinID();
  // Write last event to index file if requested on command line
  if (useIndexFile_) WriteIdxVulnerabilityFile();

  if (allIntensityBinsCheck_) CheckAllIntensityBinsPresent();

}


void ValidateVulnerability::PrintMaximumDamageBinIndex() {

  fprintf(stderr, "INFO: Maximum value of damage bin index = %d\n",
          maxDamageBin_);

}
